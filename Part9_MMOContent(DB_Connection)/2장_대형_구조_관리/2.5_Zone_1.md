# Zone #1

Room의 크기를 키우게 되면 Broadcasting 범위를 어떻게 설정할지가 난감해진다.

기존에는 내가 보는 화면 범위를 벗어난 플레이어들과 몬스터, 스킬 정보를 연산해서 서버에서 보내주고 있다.

내가 보고 있는 화면을 벗어난 플레이어와 몬스터의 정보를 굳이 자신에게 까지 보여줄 필요가 없게된다.

그래서 범위가 굉장히 중요.

프로젝트마다 범위를 뜻하는 명칭이 다름(InterestingArea, Cube 등)

중요한 것은 영역이 핵심이다.

즉 내가 주변에 있는 오브젝트들의 정보를 받을 영역을 정해줘야 한다.

해당 영역에 오브젝트가 들어오게 되면 패킷을 받아서 화면에 뿌려주는 작업을 진행해줘야 한다.

그리고 생각해야할 점은 해당 영역 안에 오브젝트들이 있는지를 매번 계산을 하는 것도 부담이 된다.

나 뿐만 아니라 상대방도 실시간으로 해당 영역을 체크를 한다는 거니깐 해당 부분을 어떻게 깔금하게 구현을 하고 성능상 이슈들도 해결을 할지가 중요한 이슈이다.

역시 다양한 방벙들이 있다.

가장 간단한 방법은 영역을 쪼개는 방법이다.

GameRoom이라는 어마어마한 큰 영역이 있었는데 이제는 큰 게임 Room을 가장의 경계선으로 구분을 지어서 관리하기 쉽게 Zone으로 쪼개준다.

이렇게 하면 장점은 

내 영역이 현재 어떤 Zone에 들어가 있는지 확인만 되면 훨씬 더 빠르게 주변 오브젝트들을 찾아줄 수 있게 된다. ⇒ 해당 Zone에 있는 오브젝트들이 무엇인지 이미 알고 있기 때문에

또한 Zone의 경계선에 있다면 양쪽 Zone을 모두 검사해주면 된다.

따라서 두 가지 작업을 진행해 볼 예정이다.

1. 내 영역 
2. Zone 범위 나누기

```csharp
using Google.Protobuf;
using Google.Protobuf.Protocol;
using Server.Data;
using System;
using System.Collections.Generic;

namespace Server.Game
{
    // Zone은 GameRoom을 쪼개서 관리하는 개념
    // 그렇다면 Zone을 누가 관리를 하면 좋을까?
    // => 맵에서 들고 있어도 괜찮고 GameRoom에서 들고 있어도 괜찮지만
    // => 가상의 개념이고 해당 Zone에 있는 Player 및 몬스터들을 찾기 위한 개념이기 때문에
    // => GameRoom에서 관리를 해보자.
    public class Zone
    {
        // 자기가 몇 번째 존인지 기입
        // 아래와 같이 Zone을 나눴을 때 몇 번째 Zone인지 저장
        // [1,1]  [1,2]  [1,3]  [1,4] 
        // [2,1]  [2,2]  [2,3]  [2,4]
        // [3,1]  [3,2]  [3,3]  [3,4]
        public int IndexY { get; private set; }
        public int IndexX { get; private set; }

        public HashSet<Player> Players { get; set; } = new HashSet<Player>();

        public Zone(int y, int x)
        {
            IndexY = y;
            IndexX = x;
        }

        public Player FindOne(Func<Player, bool> condition)
        {
            foreach (Player player in Players)
            {
                if (condition.Invoke(player))
                {
                    return player;
                }
            }
            return null;
        }
        
        public List<Player> FindAll(Func<Player, bool> condition)
        {
            List<Player> findList = new List<Player>();
            foreach (Player player in Players)
            {
                if (condition.Invoke(player))
                {
                    findList.Add(player);
                }
            }
            return findList;
        }
    }
}
```

GameRoom에서 자신의 Zone들을 관리

⇒ CellPos를 기준으로 Zone을 가지고 오기

⇒ 인접한 Zone에 있는 Player들에게만 Broadcast

```csharp
namespace Server.Game
{
    public partial class GameRoom : JobSerializer
    {
				public Zone[,] Zones { get; private set; }
        // 하나의 Zone이 몇칸인지 구분
        public int ZoneCells { get; private set; }
        public Map Map { get; private set; } = new Map();
				// ㅁㅁㅁ
        // ㅁㅁㅁ
        // ㅁㅁㅁ
        public Zone GetZone(Vector2Int cellPos)
        {
            // Cell을 계산을 할 때 주의
            // 열의 증가 => X가 오름차순으로 증가하는 식
            // 행의 증가 => Y가 내림차순으로 감소하는 식

            // ZoneIndex로 넘어가기 위해서는 ZoneCell 단위로 나눠줘야 한다.
            // (A) / B => A: 전체 맵 크기에서 x, y좌표 / 현재 Zone의 x축 Cell 크기
            int x = (cellPos.x - Map.MinX) / ZoneCells; 
						int y = (Map.MaxY - cellPos.y) / ZoneCells;

            if (x < 0 || x >= Zones.GetLength(1))
                return null;
            if (y < 0 || y >= Zones.GetLength(0))
                return null;
            
            return Zones[y, x];
        }

        public void Init(int mapId, int zoneCells)
        {
            Map.LoadMap(mapId);
            // Zone
            ZoneCells = zoneCells; // 10
            // 전체 맵 크기 1 ~ 10칸  = 1개 존
            // 전체 맵 크기 11 ~ 20칸 = 2개 존
            // 전체 맵 크기 21 ~ 30칸 = 3개 존
            int countY = (Map.SizeY + zoneCells -1) / zoneCells;
            int countX = (Map.SizeX + zoneCells -1) / zoneCells;
            Zones = new Zone[countY, countX];
            for (int y = 0; y < countY; y++)
            {
                for (int x = 0; x < countX; x++)
                {
                    Zones[y, x] = new Zone(y, x);
                }
            }

            // TEMP
            Monster monster = ObjectManager.Instance.Add<Monster>();
            monster.Init(1);
            monster.CellPos = new Vector2Int(5, 5);
            EnterGame(monster);
        }

				public void Broadcast(Vector2Int pos, IMessage packet)
        {
            List<Zone> zones = GetAdjacentZones(pos);
            
            foreach (Player p in zones.SelectMany(z => z.Players))
            {
                p.Session.Send(packet);
            }
        }

        // Broadcasting을 할 때 인접한 Zone에 있는지 체크
        // 현재 위치를 기준으로 1, 2, 3, 4 분면에 있는 Zone의 위치를 전달
        // 보통은 1개의 Zone을 전달하겠지만 경계선에 있다면 2개 이상의 Zone을 전달
        public List<Zone> GetAdjacentZones(Vector2Int cellPos, int cells = 5)
        {
            HashSet<Zone> zones = new HashSet<Zone>();

            // 1, 2, 3, 4 분면에 있는 값
            int[] delta = new int[2] { -cells, +cells};
            foreach (int dy in delta)
            {
                foreach (int dx in delta)
                {
                    int y = cellPos.y + dy;
                    int x = cellPos.x + dx;
                    Zone zone = GetZone(new Vector2Int(x, y));
                    if (zone == null)
                        continue;
                    
                    zones.Add(zone);
                }
            }

            return zones.ToList();
        }
    }
}
```

Object의 CellPos를 기준으로 현재 Zone을 가지고 와서(GetZone)

인접한 Zone을 찾은 다음(GetAdjacentZones)

해당 Zone에 있는 Player들에게 Packet을 보내준다(Broadcast)

Zone에 있는 Player들의 정보를 재구성

1. EnterGame
    
    ```csharp
    public void EnterGame(GameObject gameObject)
    {
        if (gameObject == null)
            return;
    
        GameObjectType type = ObjectManager.GetObjectTypeById(gameObject.Id);
    
        if (type == GameObjectType.Player)
        {
            Player player = gameObject as Player;
            _players.Add(gameObject.Id, player);
            player.Room = this;
    
            // DB에서 가지고 온 아이템 정보를 통해서 player의 Stat 정보를 초기화
            // 방에 입장했을 때 한번 정도 초기화를 해준다고 생각
            player.RefreshAdditionalStat();
    
            // 처음 접속하자마자 데미지가 안들어오는 버그 수정
            Map.ApplyMove(player, new Vector2Int(player.CellPos.x, player.CellPos.y));
            GetZone(player.CellPos).Players.Add(player);
    				// ...
    }
    ```
    
2. LeaveGame
    
    ```csharp
    public void LeaveGame(int objectId)
    {
        GameObjectType type = ObjectManager.GetObjectTypeById(objectId);
    
        if (type == GameObjectType.Player)
        {
            Player player = null;
            if (_players.Remove(objectId, out player) == false)
                return;
    
            GetZone(player.CellPos).Players.Remove(player);
            player.OnLeaveGame();
            Map.ApplyLeave(player);
            player.Room = null;
    				// ..
    }
    ```
    
3. 다른 Zone으로 이동
```csharp
public bool ApplyMove(GameObject gameObject, Vector2Int dest)
{
		ApplyLeave(gameObject);

		if (gameObject.Room == null)
			return false;
		if (gameObject.Room.Map != this)
			return false;

		PositionInfo posInfo = gameObject.PosInfo;

		if (CanGo(dest, true) == false)
			return false;

		// 목적지로 이동
		{
			int x = dest.x - MinX;
			int y = MaxY - dest.y;
			_objects[y, x] = gameObject;
		}

		Player p = gameObject as Player;
		if (p != null)
		{
			Zone now = gameObject.Room.GetZone(gameObject.CellPos);
			Zone after = gameObject.Room.GetZone(dest);
			if (now != after)
			{
				if (now != null)
					now.Players.Remove(p);
				if (after != null)
					after.Players.Add(p);
			}
		}
		// 실제로 좌표 이동
		posInfo.PosX = dest.x;
		posInfo.PosY = dest.y;

		return true;
}
```