## 소프트웨어 아키텍처를 이해하기 위한 주요 관점과 계층, 패턴, 관심사 등을 한눈에 볼 수 있도록 정리한 것이다.

| 구분                         | 설명                               | 예시/기술                                                         |
| -------------------------- | -------------------------------- | ------------------------------------------------------------- |
| **네트워크 계층**                | 통신 프로토콜을 계층별로 분리하여 역할을 분담        | OSI 7계층, TCP/IP 4계층                                           |
| **시스템 계층**                 | 하드웨어·OS·프로세스 수준의 추상화             | 커널, 드라이버, 스레드·메모리 관리                                          |
| **애플리케이션 계층**              | UI → 비즈니스 → 데이터 접근 순서로 책임을 분리    | Presentation, Application(Service), Domain, Persistence       |
| **인프라 계층**                 | 서비스 배포·운영을 위한 외부 인프라 구조          | CDN, Load Balancer, DB, Kubernetes, Docker                    |
| **클린 아키텍처**                | 의존성 규칙에 따라 안쪽(도메인)만 순환 참조        | Entities, Use Cases, Interface Adapters, Frameworks & Drivers |
| **헥사고날 아키텍처**              | 중심 도메인과 외부 어댑터를 분리               | 포트&어댑터(Ports & Adapters), 입출력 어댑터                             |
| **3-Tier 아키텍처**            | 전통적인 세 계층 구조                     | Web Server → Application Server → Database                    |
| **마이크로서비스**                | 기능 단위로 서비스 경계를 분리, 독립 배포 및 확장 가능 | 주문 서비스, 결제 서비스, 사용자 서비스 등                                     |
| **플러그인/모듈 구조**             | 런타임 확장 가능한 모듈화 설계                | Eclipse 플러그인, CMS 플러그인                                        |
| **메시지 기반 계층**              | 비동기 이벤트 또는 메시지로 컴포넌트 간 통신        | 메시지 브로커(RabbitMQ, Kafka), Event Sourcing, CQRS                |
| **CQRS**                   | 읽기(Query)와 쓰기(Command) 모델을 분리    | Command Handlers, Query Handlers                              |
| **Event Sourcing**         | 상태 변경 대신 이벤트를 저장, 일관성·이력 추적 용이   | 이벤트 스토어, 이벤트 리플레이                                             |
| **Cross-cutting Concerns** | 전체 계층에 걸쳐 적용되는 공통 기능 분리          | 로깅, 보안(AuthN/AuthZ), 트랜잭션, 캐싱, 검증(AOP)                        |
| **보안 계층**                  | 인증·인가·감사·암호화 등 보안 관련 책임 분리       | OAuth2, JWT, TLS, 감사 로그                                       |
| **캐시 계층**                  | 빠른 데이터 액세스를 위해 인메모리 저장           | Redis, Memcached                                              |
| **검색 인덱스 계층**              | 전문 검색 엔진을 통한 고성능 검색 지원           | Elasticsearch, Solr                                           |
| **아카이브·로그 스토리지**           | 장기 보관·분석용 데이터 레이크                | Hadoop, AWS S3, ELK 스택                                        |
| **서비스 메시**                 | 마이크로서비스 간 트래픽 관리·보안·관찰성 제공       | Istio, Linkerd                                                |
| **CI/CD 파이프라인**            | 빌드→테스트→배포의 자동화 단계별 아키텍처          | Jenkins, GitHub Actions, GitLab CI/CD                         |

> **참고:**
>
> * 이 표는 “큰 틀의 분류”이며, 실제 프로젝트에서는 여러 패턴·계층이 혼합되어 사용됩니다.
> * 특정 요구사항(성능, 확장성, 보안 등)에 맞춰 필요한 계층이나 패턴을 선택·조합해 설계하세요.


## 게임 개발 시 흔히 조합해서 사용하는 주요 아키텍처와 패턴을 영역별로 정리한 것. 실제 프로젝트에서는 이 중 몇 가지를 결합·변형해 사용합니다.

| 영역              | 사용 아키텍처/패턴                    | 역할 및 설명                                                                     |
| --------------- | ----------------------------- | --------------------------------------------------------------------------- |
| **코어 엔진 레이어**   | 모듈화(플러그인) 아키텍처                | 렌더러, 물리, 오디오, 입력 등 엔진 서브시스템을 독립 모듈로 분리하여 유지보수·재사용성 확보                       |
| **게임 로직 레이어**   | Entity-Component System (ECS) | 데이터(컴포넌트)와 동작(시스템)을 분리해 캐시 친화적·확장성 높은 게임 오브젝트 관리                            |
|                 | 스테이트 머신(State Machine)        | 캐릭터·AI·UI 등 상태 전환이 필요한 시스템의 명확한 상태 관리                                       |
|                 | 이벤트 기반(Event-Driven)          | 입력·충돌·게임 이벤트를 느슨하게 연결하여 기능 간 결합도(Coupling) 감소                               |
| **UI/UX 레이어**   | MVC/MVP/MVVM                  | 화면(View)과 로직(Controller/Presenter/ViewModel)을 분리해 테스트 용이성·유연한 화면 구성         |
| **데이터 레이어**     | Data-Driven Design            | JSON, ScriptableObject, SQLite 등 외부 설정 파일로 밸런스·콘텐츠 데이터를 관리하여 코드 변경 없이 조정 가능 |
|                 | Repository 패턴                 | 저장소 접근 코드를 추상화해 DB·파일·네트워크 캐시 등 영속화 방식 교체 시 로직 영향 최소화                       |
| **네트워크 레이어**    | 클라이언트-서버(Client-Server)       | 서버에서 권한을 관리하고 클라이언트는 렌더링·입력 처리, 보안·동기화는 서버 검증 구조                            |
|                 | 권한 위임(Authoritative Server)   | 치트·동기화 오류 방지를 위해 서버가 게임 상태 최종 판단권을 갖는 구조                                    |
| **멀티스레딩/작업 처리** | 잡 시스템(Job System)             | 물리·AI 등 CPU 집약 작업을 워커 스레드에 분배해 멀티코어 활용 최적화                                  |
|                 | 태스크 비동기(Async/Await)          | 로드·네트워크 통신 등 IO 바운드 작업을 비동기로 처리해 메인 스레드 프레임 저하 방지                           |
| **스크립트 레이어**    | 임베디드 스크립팅(Lua, Python)        | 게임 콘텐츠·AI 로직을 런타임에 로드·수정 가능하도록 분리, 개발 속도 및 모드 지원 개선                         |
| **테스트/배포**      | CI/CD 파이프라인                   | 빌드→자동화 테스트→패키징→배포 과정을 자동화해 빠른 피드백과 안정적인 릴리즈 보장                              |
| **크로스컷팅**       | 서비스 로케이터(Service Locator)     | 오브젝트 간 의존성 관리를 중앙에서 처리해 모듈 간 결합도를 낮추고 테스트 편의성 제공                            |
|                 | 의존성 주입(Dependency Injection)  | 런타임에 구현체를 주입해 모듈 교체·모킹(Mock) 테스트 용이성 제공                                     |

> **활용 팁**
>
> * **ECS** 위주로 게임 오브젝트를 관리하면서, **State Machine** 으로 AI나 UI 흐름 제어
> * 렌더링·물리를 **플러그인화**하고, **잡 시스템(Job System)** 으로 멀티코어 최적화
> * 네트워크는 **Authoritative Server** 구조를 기본으로, 필요한 경우 **클라이언트 예측(Client Prediction)** 과 **보정(Reconciliation)** 기법 추가
> * **Data-Driven** 방식을 통해 게임 밸런스·콘텐츠는 코드와 분리해 외부에서 바로 조정

이 조합을 기반으로 프로젝트 특성과 팀 역량에 맞춰 적절히 변형·적용하시면 됩니다.
