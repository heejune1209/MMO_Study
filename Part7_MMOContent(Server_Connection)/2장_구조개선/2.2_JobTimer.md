# JobTimer

잡 타이머가 필요한 이유

현재 GameRoom에다가 JobSerializer를 둬서 일종을 일감들을 Serialize해서 보관하고 있는 방식을 사용중에 있는데

만약에 클라이언트 세션에서 즉 클라쪽에서 요청이 와서 그게 패킷 핸들러를 통해 GameRoom에 있는 어떤 함수를 실행하게 되면서 그 다음에 자연스럽게 JobSerializer에 있는 부분을 꺼내서 사용하면 참 다행이겠지만

정말 극단적으로 생각했을 때 플레이어가 방 안에 한명도 없어가지고 그냥 아무런 패킷도 오지 않는다고 가정을 해보자

그럼에도 불구하고 몬스터나 다른 객체들은 있을 테니깐 누군가가 실행을 해줘야 한다.

즉 GameRoom의 Update 함수는 GameRoom에 아무도 없다고 해도 어찌됐건 누군가는 실행을 해줘야 한다. ⇒ 서버에서 담당을 해주고 있기 때문

따라서 지금은 Main문의 무한 반복문 안에서 GameRoom의 Update문을 돌려주고 있는데(Pooling 방식) 서버가 아니라 클라인 것 마냥 Loop를 돌면서 실행을 해주고 있었다.

이것이 좋은 방법은 아니다.

무한 루프를 돈다는 것 자체가 좋지 않기도 하고 경우에 따라 지금 당장 실행을 하지는 않지만 예약을 하고 싶은 경우가 많이 발생할 것이다.

즉 틱을 계산해서 일정한 시간이 될때까지 실행이 되지 않도록 강제한 부분이 있는데 (ex. Monster AI 부분) 이것은 사실 굉장히 무식한 방법이다.

어떻게 보면 업데이트를 계속하면서 시간이 됐는지 여부를 계속 확인하는 것인데(틱을 계속 체크) 

유니티에서는 이렇게 틱을 계속 체크한 것이 아니라 코루틴이든 시간을 체크해서 필요할 때 해당 함수가 실행될 수 있도록 구현이 가능했다.

나중에 몬스터가 몇만 마리가 되면 이렇게 틱을 계산하는 if을 아끼고 싶게 될 것이다.

그래서 어찌됐건 일정 시간이 되면은 예약하는 시스템이 필요하고 Update문을 어떻게 구현을 해야 효과적으로 동작할지를 고민해야 한다.

Update문을 어떤 주기로 반복을 할지는 게임에 따라 다르다.

MMO, 

클라 60FPS, 0.1초에 1번씩 ⇒ 0.05초에 1번씩(50ms)

LoL, FPS

⇒ 자주 체크

⇒ 클라 60FPS, 1초에 1번씩

여튼 정책을 결정해야 한다.

여태껏 사용해온 Push 방식은 Push를 가장 처음에 하게 되면(아무도 실행을 하고 있지 않다면) 자신이 실행까지 담당을 하게 된다.

이렇게 만드는 경우도 있고,

Push는 정말 Push만 하고 Flush는 다른 곳에서 하는 방법도 있다.

그렇다면 Flush를 어디서 해야줘야 할까?

GameRoom의 Update문 안에서 해주는 것이 가장 좋다.

그렇다면 GameRoom의 Update문은 어디서 해주는 것이 좋을까?

Main문의 Update문 안에서 매틱마다 Update문을 돌리는 것은 너무 무식한 방법이니깐

C#에 있는 기능을 활용해보자.

```csharp
static List<System.Timers.Timer> _timers = new List<System.Timers.Timer>();

static void TickRoom(GameRoom room, int tick = 100)
{
		var timer = new System.Timers.Timer();
		timer.Interval = tick;
		// 특정 시간이 지났다면 어떤 이벤트를 실행할 것인지를 결정
		timer.Elapsed += ((s, e) =>  room.Update());
		// 자동으로 리셋
		timer.AutoReset = true;

		// Enabled이 true가 되면 시작
		timer.Enabled = true;

		_timers.Add(timer);
}
```

TickRoom을 호출하면 원하는 시간에 한번씩 timer에 예약한 이벤트가 실행이 되도록 동작한다.

그리고 TickRoom을 통해 타이머를 맞춰놓으면 Main 쓰레드에서 뿐만 아니라 다른 쓰레드에서도 동작을 시켜준다. (Timer에서 쓰레드를 뽑아서 사용해줌)

즉 Timer에서 뽑은 쓰레드가 결국 GameRoom의 Update까지 같이 실행해주게 된다.

이렇게 Push 따로 Flush 따로 작업을 했을 경우에 장단점이 있다.

장점은 생각하기가 쉽다. ⇒ 좀더 직관적이다.

단점은 반응 속도에 있어서 조금 손해를 보게 된다 ⇒ 이전에는 패킷이 오자마자 실행을 했지만 지금은 운이 안좋을 땐 50ms 뒤에 실행이 되기 때문이다. 약간의 딜레이가 발생