# Search AI

현재까지 구현한 인공지능을 보면 BaseController에서 State가 변경되었을 때 즉 자신의 상태에 따라 특정 행동을 할 수 있는 Update문을 만들어 놓았다.

이 방법이 인공지능을 구현할 때 사용하는 기본적이면서도 효과적인 방법이다.

소위 인공지능을 구현할 때 복잡하고 어려운 데이터 시트로 조절해야 할 경우에 블랙보드를 이용하는 즉 Behavior Tree를 이용하는 AI를 사용하는 경우가 많은데 경우에 따라서 이것이 필수인 것은 아니다.

지금과 같이 간단하게 만드는 경우에는 이렇게 상태를 조절해서 AI를 구현하는 방법 즉, 유한상태기계 방식이 가장 효과적이다.

몬스터의 조정 주체는 결국 서버이다.

몬스터의 종류가 굉장히 다양할 텐데 그때마다 Monster 클래스를 상속 받아서 새로운 클래스를 만들어야 되나 하는 의문이 생긴다.

실질적으로 몬스터의 성격이 매우 다르면 그렇게 해도 되기는 한데 일반적인 MMORPG의 경우는 그렇게 각 몬스터마다 클래스를 만들지 않고 Monster 클래스를 공용으로 사용한다.

이거를 잘 쪼개서 데이터 시트를 잘 활용해서 잘 만들어주는 경우가 많다.

그리고 AI를 컨트롤 하는 클래스를 별도로 빼놔서 복잡하게 되어있는 경우가 많이 있었다.

유니티의 경우는 코루틴을 활용하여 스킬 쿨타임이나 1초마다 진행이 되는 것을 관리를 했었는데 이것을 가장 무식하게 해결할 수 있는 방법은 매틱마다 업데이트문을 실행을 하면서 별도로 시간을 관리해서 내가 진짜로 해당 메서드를 실행할 때가 되었는지를 체크하는 방법이 있다.

우선 무식한 방법으로 작업을 진행을 하다가 차츰 우아한 방법을 사용하는 것을 알려줄 예정

일단은 간단하게 만들어 보자 

같은 공간 안에서 플레이어를 찾는 방법에 대해서

Room으로 구역을 나눠서 MMORPG를 구현하는 경우에는 크게 문제가 되지는 않지만 심리스 게임에 경우에는 한 구역에 수백명이 모일 수도 있게 된다.

이럴 경우에는 섹터를 나눠서 해당 섹터에 있는 플레이어를 찾는 방식으로 작업을 진행하는데 이를 위해서는 많은 알고리즘 지식이 필요하다.

현재 강의에서는 최대한 간단한게 구현을 하는 것이 목표이기 때문에 GameRoom 안에 있는 플레이어들의 정보를 모두 검색하는 방식으로 진행할 예정이다.

길찾기를 할 때 꼭 마지막 목적이 아니라고 해도 내가 가는 도중에 오브젝트가 있는지 여부도 굉장히 중요하다.

길찾기를 할 때는 일단은 처음부터 모든 오브젝트를 계산해서 연산하는 경우는 거의 없다. 

왜냐하면 모든 오브젝트가 이미 이동을 하고 있다 보니깐 그렇게까지 계산을 하기 보다는 일단은 객체들이 없다고 가정을 하고 계산을 한 다음에 내 앞을 가로 막는 대상을 만나게 되면은 그때가서 다른 방법으로 계산하는 방법이 조금 더 흔한 방법이다.

GameRoom의 업데이트문

player의 버프나 어느정도 시간이 지나면 종료 되는 버프의 경우 나중에 서버에서 관리를 해줘야할 필요가 있다. 

지금은 플레이어의 경우 클라에서 관리를 해서 클라에서 계산한(희망하는) 좌표로 이동하도록 작업을 해달라고 서버에게 보내고 있었기 때문에 GameRoom에서 이렇게 Projectile만 업데이트문으로 돌려주고 플레이어는 업데이트를 안해주고 있었다.

하지만 몬스터의 경우는 서버에서 담당하기 때문에 몬스터도 업데이트를 시켜줘야 한다.