## 쓰레드와 캐시

![image](https://user-images.githubusercontent.com/75019048/138374355-e0e21e2d-4024-45f8-9af9-66e5e82e96b0.png)

DB란 물류 창고와 비슷한 개념이다.

3가지 요구사항을 만족해야 하는데 보통 한 가지를 만족하면 나머지를 포기해야 하는 경우가 발생하게 된다.

따라서 다양한 꼼수를 활용해서 위의 3가지 요구사항을 만족 할 수 있도록 하는 것이 핵심이다.

 

DB에서 크게 2가지 경우가 있는데

데이터를 가지고 오는 경우(READ) 데이터를 쓰는 경우(WRITE)가 있다.

데이터를 가지고 오는 경우 아래와 같은 작업을 하게 된다.

![image](https://user-images.githubusercontent.com/75019048/138374378-ded59eb9-b6ed-491b-85c0-5369b22d566d.png)

SQL 파싱이란 컴파일과 비슷한 과정을 하는 것이다.

즉 SQL 구문을 분석해서 어떤 식으로 데이터를 가지고 와야 할 것인지 해석하는 과정

데이터를 쓰는 경우는 아래와 같은 작업을 하게 된다.

![image](https://user-images.githubusercontent.com/75019048/138374398-8da56d87-2a34-4cdc-bffc-dc5008a5e723.png)

이렇게 순진하게 동작을 했다면 빠르게를 만족하기 못할 것이다.

즉 결과를 클라이언트에 전달을 할 때까지 기다려야 한다면 클라 입장에서는 요청이 너무 오래 걸리게 된다.

하지만 이렇게 완료(성공)할 때까지 기다려야하는 것인지 의문이다.

따라서 아래와 같이 분리하는 상황을 생각해야 한다.

![image](https://user-images.githubusercontent.com/75019048/138374438-90819956-9733-4f10-a2ed-9c44c8a095cc.png)

데이터를 쓰는 것은 어떻게든 책임지고 할 테니깐 OK 사인을 먼저 전달하는 방법

(데이터를 가지고 오는 것은 기다려야겠지만)

데이터 베이스에서 많이라는 덕목을 실천하기 위해서는 데이터베이스도 멀티쓰레드로 돌아가야 한

![image](https://user-images.githubusercontent.com/75019048/138374454-d6e2ecae-165c-4b23-98cc-d554adef2716.png)

영업 전문 쓰레드

뒤처리/운영 전문 쓰레드

이렇게 담당하는 쓰레드를 구문을 해주게 되면

영업 전문 쓰레드는 반응성(요청이 들어왔을 때 바로 처리)을 높여 줄 수 있다.

메모리 캐시 

![image](https://user-images.githubusercontent.com/75019048/138374468-5062d6f4-5f3b-44e4-8984-e093c78e2234.png)

영역을 위와 같이 나눴음에도 아직 해결 되지 않은 문제가 있는데 READ의 경우는 해결이 되지가 않는다. 

데이터를 실제로 가지고 올 때까지 결과를 클라이언트에게 전달을 해줄 수가 없게 된다. 위와 같은 꼼수를 사용 할 수가 없다.

따라서 캐시의 개념이 등한다.

즉 RAM에 접근하는 것이 아니라 L1, L2 캐쉬에 데이터를 저장하는 느낌으로 임시 창고(캐시)를 둬서 그곳에 데이터를 임시로 보관을 해줘서 아래와 같은 프로세스를 거친다.

![image](https://user-images.githubusercontent.com/75019048/138374487-f6cdedc0-bd8f-4bbe-a708-788bb8593b9d.png)

즉 READ를 해야하는 상황에서 메모 캐시를 활용할 때 해당 메모리 캐시에 데이터가 있는지 여부를 확인하고 클라에게 전달해준다.

근데 데이터가 너무 방대한데 임시창고를 활용 할 수 있을까?

애초에 데이터를 불러올 때 데이터 하나만 불러오는 것이 아니라 데이터 블록 단위로 불러오게 된

![image](https://user-images.githubusercontent.com/75019048/138374504-0fa35fef-34f1-4b13-b1e3-bfafeba8fa8f.png)

위와 같이 임시 창고에 데이터가 없을 때는 어쩔 수 없이 DB로 가서 데이터를 가지고 오는데 주변에 있는 여러 데이터를 한번에 가지고 와서 임치 창고에 저장을 한 다음에 결과 값을 전달을 해주는 과정을 거치게 된다.

혹시라도 다음 단계에서 인접한 데이터를 찾게 된다면 임시 창고에 저장했던 데이터를 가지고 와서 사용한다.

이렇게 캐시를 활용해서 READ 속도를 최적화 시킬 수 있다.

그 다음에 위의 경우는 데이터에 대한 경우고 인덱스를 활용하는 것은 아래와 같다.

![image](https://user-images.githubusercontent.com/75019048/138374509-0b67214e-657f-49eb-8b30-4016d668f7b0.png)

풀스캔의 경우는 INDEX가 큰 효과를 발휘하지 못하지만 그게 아니라 특정 조건을 위해서 인덱스를 활용하면 빠르게 데이터를 찾을 수 있게 된다.

그러면 인덱스는 과연 어디에 저장이 되어 있을까?

인덱스도 역시 DB에 저장이 되어 있다.

결국 위와 같이 SQL 쿼리를 파싱을 할 때 인덱스를 활용하는 것이 좋다는 결론이 나오면 일단 임시 창고에 가서 인덱스가 저장이 되어 있는지 확인을 먼저 하고 임시창고에 인덱스가 있다면 역시 해당 데이터가 임시창고에 있는지를 확인 하는 방법으로 데이터를 가지고 오게 된다.

하지만 임시 창고가 꽉 차게 되면 어떻게 될까?

![image](https://user-images.githubusercontent.com/75019048/138374519-76c2cc72-b3eb-4532-9d8e-54c5cf6ec89a.png)

즉 시간이 흘러 임시 창고가 꽉차게 되는 경우를 막기 위해서 주기적 정리를 하게 된다.

보통은 LRU 알고리즘(최근에 활용도가 낮았던 순서로 정리)을 활용하여 정리한다.

결국 핵심은 클라에서 DB로 데이터를 요청할 때 항상 하드까지 가서 데이터를 가지고 오는 것이 아닌 것이 핵심이다.

그렇게면 임시 창고는 물리적으로 어떤 하드웨어일까?

RAM이 맞게 된다.

서버의 경우는 CPU 캐쉬가 임시 창고 역할을 하게 되었는 데 DB의 경우는 RAM에 접근해서 데이터를 가지고 오는 경우만 해도 행복하다.

DB 시스템이라고 해서 마법을 부리는 것이 아니라 서버와 마찬가지로 어떤 식으로든 컴퓨터 기능을 활용하는 프로그램일 뿐이다.

당연히 쉽게 만들 수는 없겠지만 결국 프로그램 언어로 돌아가는 하나의 프로그램으로 생각하면 된다.

따라서 서버에서 활용했던 멀티 쓰레드 기술이라거나 메모리 캐쉬를 활용하는 것이 거의 동일하다.
