## 북마크 룩업

```sql
USE Northwind;

-- 북마크 룩업
-- Index Scan vs Index Seek
-- Index Scan이 항상 나쁜 것은 아니고
-- Index Seek가 항상 좋은 것은 아니다.

-- 인덱스를 활용하는데 어떻게 느릴 수가 있을까?

-- NonClustered 
--				1
-- 2[(data1, data2, ... data28)]  3  4  5  6

-- Clustered
--	   1
-- 2 3 4 5 6 

-- 클러스터드 같은 경우엔 데이터가 리프페이지에 있다고 했었다
-- 그리고 논 클러스터드 같은 경우엔 리프페이지에 있는 것이 아니라 데이터를 찾을 수 있는 열쇠를 들고 있다고 했다.
-- 그래서 만약에 클러스터드 인덱스가 따로 없다고 가정을 하면, 
-- Heap Table 이라는게 생기는데 그때는 non-clustered leaf에서는 RID라는 걸 이용해서 힙테이블에 찾아간다 했었고,
-- 클러스터드 인덱스가 하나라도 있다고 가정을 하면 그냥 클러스터드 인덱스의 키값을 가지고 있어가지고 
-- 걔를 이용해서 직접 이런식으로 클러스터드 인덱스 찾아가서 데이터를 찾게 된다고 얘기를 했었다

-- Heap Table[{Page} {Page} {Page}]

-- Clustered의 경우 Index Seek가 느릴 수가 없다.
-- NonClustered의 경우, 데이터가 Leaf Page에 없다
-- 따라서 한 번 더 타고 가야함
-- 1) RID -> Heap Table (Bookmark Lookup)
-- 2) Key -> Clustered Page로 찾아감

SELECT *
INTO TestOrders
FROM Orders;

SELECT *
FROM TestOrders;

CREATE NONCLUSTERED INDEX Orders_Index01
ON TestOrders(CustomerID)

-- 인덱스 번호
SELECT index_id, name
FROM sys.indexes
WHERE object_id = object_id('TestOrders');

-- 조회
DBCC IND('Northwind', 'TestOrders', 2)

--			9176
-- 9136	    9144	 9145
-- HEAP Table [{Page} {Page}]

SET STATISTICS TIME ON;
SET STATISTICS IO ON;
SET STATISTICS PROFILE ON; -- 실제로 실행된 순서

-- 기본 탐색을 해보자
SELECT *
FROM TestOrders
WHERE CustomerID = 'QUICK';

-- 결과 => 논리적 읽기 20, 경과시간 : 23ms

-- CustomerID가 NonClusteredIndex임에도 Table Scan이 나오고 있다
-- 왜그럴까?
-- 기본적으로 데이터베이스 내부에서 Scan을 하는 것이 더 빠르다고 판단해서 Scan으로 동작을 하고 있다.

-- 강제로 인덱스를 활용
SELECT *
FROM TestOrders WITH(INDEX(Orders_Index01))
WHERE CustomerID = 'QUICK';
-- 결과 => 논리적 읽기 30, 경과시간 : 22ms

-- 인덱스를 활용하는 방법이 더 느렸다.
-- 논리적 읽기가 30인 이유는 SET STATISTICS PROFILE ON을 통해 알 수가 있다.

-- Lookup을 줄이기 위한 몸부림
SELECT *
FROM TestOrders WITH(INDEX(Orders_Index01))
WHERE CustomerID = 'QUICK' AND ShipVia = 3;
-- 논리적 읽기 : 30

DROP INDEX TestOrders.Orders_Index01;

-- CustomerID와 ShipVia 복합 인덱스를 활용해서 Lookup을 줄여보자
-- 1번 옵션) Covered Index
CREATE NONCLUSTERED INDEX Orders_Index01
ON TestOrders(CustomerID, ShipVia);

-- 8번 룩업을 시도해서 8번 다 꽝없이 찾음
SELECT *
FROM TestOrders WITH(INDEX(Orders_Index01))
WHERE CustomerID = 'QUICK' AND ShipVia = 3;
-- 논리적 읽기 : 10

-- Q) 그럼 조건1 AND 조건2 필요하면, 무조건 INDEX(조건1, 조건2)를 추가하면 될까?
-- A) NO! 꼭 그렇지는 않다. DML(Insert, Update, Delete) 할 때 작업 부하가 증가하게 된다.

-- 2번 옵션)
-- 이렇게 하면 키 값 자체는 CustomerID만 활용하기 때문에 
-- 데이터 정렬이 심하게 이루어지지는 않지만 INCLUDE (ShipVia)를 해줬다는 것은
-- LeafPage에다가 ShipVia에 대한 정보를 들고 있다는 이야기다.

CREATE NONCLUSTERED INDEX Orders_Index01
ON TestOrders(CustomerID) INCLUDE (ShipVia);

-- 8번 룩업을 시도해서 8번 다 꽝없이 찾음
SELECT *
FROM TestOrders WITH(INDEX(Orders_Index01))
WHERE CustomerID = 'QUICK' AND ShipVia = 3;
-- 논리적 읽기 10

-- 위와 같은 눈물겨운 노력에도 답이 없다면
-- Clustered Index 활용을 고려할 수 있다.
-- But! Clustered Index는 테이블 당 1개만 사용할 수 있다.
-- 따라서 테이블 당 정말 중요한 키값에만 걸어줘야 한다.

-- 결론 --
-- NonClustered Index가 악영향을 주는 경우?
	-- 북마크 룩업이 심각한 부하를 야기할 때
	-- 애당초 애써서 NonClustered Index로 찾았다고 해도
	-- 해당 Leaf Page에서 다시 실제 데이터에 접근하는 북마크 룩업이 
	-- 느리면 Index를 활용하는 의미가 퇴색이 된다.
-- 대안?
		-- 옵션 1) Covered Index (검색할 모든 컬럼을 포함하겠다)
		-- 옵션 2) Index에다가 Include로 힌트를 남긴다.
		-- 옵션 3) Clustered 고려 (단 1번만 사용할 수 있는 궁극기..) -> NonClustered에 악영향을 주게 된다.
				-- 왜 악영향?
				-- NonClustered Index는 Leaf Page에서 데이터를 찾았는데 Clustered가 없으면 
				-- RID를 가지고 Heap Table에서 데이터를 찾았지만, Clustered가 있으면 HeapTable은 사라지고
				-- Key를 가지고 다시 Clustered에서 다시 값을 찾게 되기 때문이다.
				-- 그럼에도 Clustered를 사용하면 북마크 룩업을 자체를 아에 없앨 수 있을 것이다.
				-- Clustered는 Leaf Page에 실제 데이터가 있기 때문이다.
```
# 북마크 룩업 & 인덱스 최적화 사고 흐름

## 1. 핵심 키워드  
- **Bookmark Lookup** (RID → Heap / Key → Clustered)  
- **Index Scan** vs **Index Seek**  
- **Table Scan** (엔진 판단)  
- **Covered Index**  
- **INCLUDE 컬럼**  
- **Clustered Index 한정**  

## 2. 머릿속 흐름 정립 순서

1. **저장 구조 파악**  
   - Heap Table vs Clustered Leaf  
   - Non-Clustered Leaf는 **RID** 또는 **Clustered Key**를 들고 있음  

2. **접근 방식 판별**  
   - WHERE 절 + 출력 컬럼 → **Scan** 또는 **Seek**  
   - 옵티마이저가 “Scan이 더 빠르다” 판단 시 **Table Scan** 선택  

3. **성능 측정**  
   - `SET STATISTICS IO/TIME/PROFILE ON`  
   - **Logical Reads**, **Elapsed Time**, **실행 계획 순서** 확인  

4. **문제 진단**  
   - **Non-Clustered Seek** → 빈번한 **Bookmark Lookup**  
   - **Forced Index Hint** (`WITH(INDEX(...))`) 로도 느릴 수 있음  

5. **인덱스 개선 전략**  
   1. **Covered Index** (검색·출력 컬럼 모두 키에 포함)  
   2. **INCLUDE 컬럼** (키는 최소, 추가 컬럼만 Leaf에 포함)  
   3. **Clustered Index 고려** (최후의 수단, 테이블당 1개)  

6. **트레이드오프 검토**  
   - DML(INSERT/UPDATE/DELETE) 부하 증가  
   - Bookmark Lookup 제거 vs 인덱스 관리 비용  

---

각 단계에서 위 **키워드**를 떠올리며,  
“저장 구조 → 접근 방식 → 성능 측정 → 문제 진단 → 인덱스 개선 → 비용 분석”  
순으로 머릿속에 개념 지도를 그려보세요.  
